"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectorBarItemAtPosition = void 0;
var _store = require("@mui/x-internals/store");
var _useChartCartesianAxisRendering = require("./useChartCartesianAxisRendering.selectors");
var _useChartSeries = require("../../corePlugins/useChartSeries");
var _getBandSize = require("../../../../internals/getBandSize");
var _scaleGuards = require("../../../../internals/scaleGuards");
var _invertScale = require("../../../../internals/invertScale");
const selectorBarItemAtPosition = exports.selectorBarItemAtPosition = (0, _store.createSelector)(_useChartCartesianAxisRendering.selectorChartXAxis, _useChartCartesianAxisRendering.selectorChartYAxis, _useChartSeries.selectorChartSeriesProcessed, function selectorBarItemAtPosition({
  axis: xAxes,
  axisIds: xAxisIds
}, {
  axis: yAxes,
  axisIds: yAxisIds
}, processedSeries, svgPoint) {
  const {
    series,
    stackingGroups = []
  } = processedSeries?.bar ?? {};
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  let item = undefined;
  for (let stackIndex = 0; stackIndex < stackingGroups.length; stackIndex += 1) {
    const group = stackingGroups[stackIndex];
    const seriesIds = group.ids;
    for (const seriesId of seriesIds) {
      const aSeries = (series ?? {})[seriesId];
      const xAxisId = aSeries.xAxisId ?? defaultXAxisId;
      const yAxisId = aSeries.yAxisId ?? defaultYAxisId;
      const xAxis = xAxes[xAxisId];
      const yAxis = yAxes[yAxisId];
      const bandAxis = aSeries.layout === 'horizontal' ? yAxis : xAxis;
      const continuousAxis = aSeries.layout === 'horizontal' ? xAxis : yAxis;
      const bandScale = bandAxis.scale;
      const svgPointBandCoordinate = aSeries.layout === 'horizontal' ? svgPoint.y : svgPoint.x;
      if (!(0, _scaleGuards.isBandScale)(bandScale)) {
        continue;
      }
      const dataIndex = (0, _invertScale.getDataIndexForOrdinalScaleValue)(bandScale, svgPointBandCoordinate);
      const {
        barWidth,
        offset
      } = (0, _getBandSize.getBandSize)(bandScale.bandwidth(), stackingGroups.length, bandAxis.barGapRatio);
      const barOffset = stackIndex * (barWidth + offset);
      const bandValue = bandAxis.data?.[dataIndex];
      if (bandValue == null) {
        continue;
      }
      const bandStart = bandScale(bandValue);
      if (bandStart == null) {
        continue;
      }
      const bandBarStart = bandStart + barOffset;
      const bandBarEnd = bandBarStart + barWidth;
      const bandBarMin = Math.min(bandBarStart, bandBarEnd);
      const bandBarMax = Math.max(bandBarStart, bandBarEnd);
      if (svgPointBandCoordinate >= bandBarMin && svgPointBandCoordinate <= bandBarMax) {
        // The point is inside the band for this series
        const svgPointContinuousCoordinate = aSeries.layout === 'horizontal' ? svgPoint.x : svgPoint.y;
        const bar = aSeries.visibleStackedData[dataIndex];
        const start = continuousAxis.scale(bar[0]);
        const end = continuousAxis.scale(bar[1]);
        if (start == null || end == null) {
          continue;
        }
        const continuousMin = Math.min(start, end);
        const continuousMax = Math.max(start, end);
        if (svgPointContinuousCoordinate >= continuousMin && svgPointContinuousCoordinate <= continuousMax) {
          item = {
            seriesId,
            dataIndex
          };
        }
      }
    }
  }
  if (item) {
    return {
      type: 'bar',
      seriesId: item.seriesId,
      dataIndex: item.dataIndex
    };
  }
  return undefined;
});