"use strict";
'use client';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useChartVisibilityManager = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _useEventCallback = _interopRequireDefault(require("@mui/utils/useEventCallback"));
var _useEffectAfterFirstRender = require("@mui/x-internals/useEffectAfterFirstRender");
var _useChartVisibilityManager = require("./useChartVisibilityManager.selectors");
var _visibilityParamToMap = require("./visibilityParamToMap");
const useChartVisibilityManager = ({
  store,
  params,
  seriesConfig,
  instance
}) => {
  // Manage controlled state
  (0, _useEffectAfterFirstRender.useEffectAfterFirstRender)(() => {
    if (params.hiddenItems === undefined) {
      return;
    }
    if (process.env.NODE_ENV !== 'production' && !store.state.visibilityManager.isControlled) {
      console.error([`MUI X Charts: A chart component is changing the \`hiddenItems\` from uncontrolled to controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', 'Decide between using a controlled or uncontrolled for the lifetime of the component.', "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
    }
    store.set('visibilityManager', (0, _extends2.default)({}, store.state.visibilityManager, {
      visibilityMap: (0, _visibilityParamToMap.visibilityParamToMap)(params.hiddenItems, seriesConfig)
    }));
  }, [store, params.hiddenItems, seriesConfig]);
  const hideItem = (0, _useEventCallback.default)(identifier => {
    const visibilityMap = store.state.visibilityManager.visibilityMap;
    const id = instance.serializeIdentifier(identifier);
    if (visibilityMap.has(id)) {
      return;
    }
    const newVisibilityMap = new Map(visibilityMap);
    newVisibilityMap.set(id, identifier);
    store.set('visibilityManager', (0, _extends2.default)({}, store.state.visibilityManager, {
      visibilityMap: newVisibilityMap
    }));
    params.onHiddenItemsChange?.(Array.from(newVisibilityMap.values()));
  });
  const showItem = (0, _useEventCallback.default)(identifier => {
    const visibilityMap = store.state.visibilityManager.visibilityMap;
    const id = instance.serializeIdentifier(identifier);
    if (!visibilityMap.has(id)) {
      return;
    }
    const newVisibilityMap = new Map(visibilityMap);
    newVisibilityMap.delete(id);
    store.set('visibilityManager', (0, _extends2.default)({}, store.state.visibilityManager, {
      visibilityMap: newVisibilityMap
    }));
    params.onHiddenItemsChange?.(Array.from(newVisibilityMap.values()));
  });
  const toggleItem = (0, _useEventCallback.default)(identifier => {
    const visibilityMap = store.state.visibilityManager.visibilityMap;
    const id = instance.serializeIdentifier(identifier);
    if (visibilityMap.has(id)) {
      showItem(identifier);
    } else {
      hideItem(identifier);
    }
  });
  return {
    instance: {
      hideItem,
      showItem,
      toggleItemVisibility: toggleItem
    }
  };
};
exports.useChartVisibilityManager = useChartVisibilityManager;
useChartVisibilityManager.getInitialState = (params, _, seriesConfig) => {
  const initialItems = params.hiddenItems ?? params.initialHiddenItems;
  return {
    visibilityManager: {
      visibilityMap: initialItems ? (0, _visibilityParamToMap.visibilityParamToMap)(initialItems, seriesConfig) : _useChartVisibilityManager.EMPTY_VISIBILITY_MAP,
      isControlled: params.hiddenItems !== undefined
    }
  };
};
useChartVisibilityManager.params = {
  onHiddenItemsChange: true,
  hiddenItems: true,
  initialHiddenItems: true
};