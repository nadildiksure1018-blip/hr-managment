"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _d3Shape = require("@mui/x-charts-vendor/d3-shape");
var _getLabel = require("../../internals/getLabel");
var _angleConversion = require("../../internals/angleConversion");
const getSortingComparator = (comparator = 'none') => {
  if (typeof comparator === 'function') {
    return comparator;
  }
  switch (comparator) {
    case 'none':
      return null;
    case 'desc':
      return (a, b) => b - a;
    case 'asc':
      return (a, b) => a - b;
    default:
      return null;
  }
};
const seriesProcessor = (params, dataset, isItemVisible) => {
  const {
    seriesOrder,
    series
  } = params;
  const defaultizedSeries = {};
  seriesOrder.forEach(seriesId => {
    // Filter out hidden data points for arc calculation
    const visibleData = series[seriesId].data.filter((_, index) => {
      return isItemVisible?.({
        type: 'pie',
        seriesId,
        dataIndex: index
      });
    });
    const visibleArcs = (0, _d3Shape.pie)().startAngle((0, _angleConversion.deg2rad)(series[seriesId].startAngle ?? 0)).endAngle((0, _angleConversion.deg2rad)(series[seriesId].endAngle ?? 360)).padAngle((0, _angleConversion.deg2rad)(series[seriesId].paddingAngle ?? 0)).sortValues(getSortingComparator(series[seriesId].sortingValues ?? 'none'))(visibleData.map(piePoint => piePoint.value));

    // Map arcs back to original data, maintaining original indices
    let visibleIndex = 0;
    defaultizedSeries[seriesId] = (0, _extends2.default)({
      labelMarkType: 'circle',
      valueFormatter: item => item.value.toLocaleString()
    }, series[seriesId], {
      data: series[seriesId].data.map((item, index) => {
        const itemId = item.id ?? `auto-generated-pie-id-${seriesId}-${index}`;
        const isHidden = !isItemVisible?.({
          type: 'pie',
          seriesId,
          dataIndex: index
        });
        let arcData;
        if (isHidden) {
          // For hidden items, create a zero-size arc starting at the previous visible arc's end angle
          // and ending at the same angle
          const startAngle = visibleIndex > 0 ? visibleArcs[visibleIndex - 1].endAngle : (0, _angleConversion.deg2rad)(series[seriesId].startAngle ?? 0);
          arcData = {
            startAngle,
            endAngle: startAngle,
            padAngle: 0,
            value: item.value,
            index
          };
        } else {
          arcData = visibleArcs[visibleIndex];
          visibleIndex += 1;
        }
        const processedItem = (0, _extends2.default)({}, item, {
          id: itemId,
          hidden: isHidden
        }, arcData);
        return (0, _extends2.default)({
          labelMarkType: 'circle'
        }, processedItem, {
          formattedValue: series[seriesId].valueFormatter?.((0, _extends2.default)({}, processedItem, {
            label: (0, _getLabel.getLabel)(processedItem.label, 'arc')
          }), {
            dataIndex: index
          }) ?? processedItem.value.toLocaleString()
        });
      })
    });
  });
  return {
    seriesOrder,
    series: defaultizedSeries
  };
};
var _default = exports.default = seriesProcessor;