import _extends from "@babel/runtime/helpers/esm/extends";
import { createSelector, createSelectorMemoized } from '@mui/x-internals/store';
import { selectorChartXAxis, selectorChartYAxis } from "./useChartCartesianAxisRendering.selectors.js";
import { selectorChartsInteractionXAxisIndex, selectorChartsInteractionXAxisValue, selectorChartsInteractionYAxisIndex, selectorChartsInteractionYAxisValue } from "./useChartCartesianInteraction.selectors.js";
import { selectorChartsKeyboardXAxisIndex, selectorChartsKeyboardYAxisIndex } from "../useChartKeyboardNavigation/useChartKeyboardNavigation.selectors.js";
import { selectorChartsLastInteraction } from "../useChartInteraction/useChartInteraction.selectors.js";
import { selectorBrushShouldPreventAxisHighlight } from "../useChartBrush/index.js";

/**
 * The return type of the `selectAxisHighlightWithValue`.
 */

function getAxisHighlight(lastInteractionUpdate, pointerHighlight, keyboardHighlight) {
  if (lastInteractionUpdate === 'pointer') {
    if (pointerHighlight) {
      return [pointerHighlight];
    }
    if (keyboardHighlight) {
      return [keyboardHighlight];
    }
  }
  if (lastInteractionUpdate === 'keyboard') {
    if (keyboardHighlight) {
      return [keyboardHighlight];
    }
    if (pointerHighlight) {
      return [pointerHighlight];
    }
  }
  return [];
}
const selectorChartControlledCartesianAxisHighlight = state => state.controlledCartesianAxisHighlight;
const selectAxisHighlight = (computedIndex, axis, controlledAxisItems, keyboardAxisItem, lastInteractionUpdate, isBrushSelectionActive) => {
  if (isBrushSelectionActive) {
    return [];
  }
  if (controlledAxisItems !== undefined) {
    return controlledAxisItems.filter(item => axis.axis[item.axisId] !== undefined).map(item => item);
  }
  const pointerHighlight = computedIndex !== null && {
    axisId: axis.axisIds[0],
    dataIndex: computedIndex
  };
  const keyboardHighlight = keyboardAxisItem != null && keyboardAxisItem;
  return getAxisHighlight(lastInteractionUpdate, pointerHighlight, keyboardHighlight);
};
export const selectorChartsHighlightXAxisIndex = createSelectorMemoized(selectorChartsInteractionXAxisIndex, selectorChartXAxis, selectorChartControlledCartesianAxisHighlight, selectorChartsKeyboardXAxisIndex, selectorChartsLastInteraction, selectorBrushShouldPreventAxisHighlight, selectAxisHighlight);
export const selectorChartsHighlightYAxisIndex = createSelectorMemoized(selectorChartsInteractionYAxisIndex, selectorChartYAxis, selectorChartControlledCartesianAxisHighlight, selectorChartsKeyboardYAxisIndex, selectorChartsLastInteraction, selectorBrushShouldPreventAxisHighlight, selectAxisHighlight);
const selectAxisHighlightWithValue = (computedIndex, computedValue, axis, controlledAxisItems, keyboardAxisItem, lastInteractionUpdate, isBrushSelectionActive) => {
  if (isBrushSelectionActive) {
    return [];
  }
  if (controlledAxisItems !== undefined) {
    return controlledAxisItems.map(item => _extends({}, item, {
      value: axis.axis[item.axisId]?.data?.[item.dataIndex]
    })).filter(({
      value
    }) => value !== undefined);
  }
  const pointerHighlight = computedValue != null && {
    axisId: axis.axisIds[0],
    value: computedValue
  };
  if (pointerHighlight && computedIndex != null) {
    pointerHighlight.dataIndex = computedIndex;
  }
  const keyboardValue = keyboardAxisItem != null && axis.axis[keyboardAxisItem.axisId]?.data?.[keyboardAxisItem.dataIndex];
  const keyboardHighlight = keyboardAxisItem != null && keyboardValue != null && _extends({}, keyboardAxisItem, {
    value: keyboardValue
  });
  return getAxisHighlight(lastInteractionUpdate, pointerHighlight, keyboardHighlight);
};
export const selectorChartsHighlightXAxisValue = createSelectorMemoized(selectorChartsInteractionXAxisIndex, selectorChartsInteractionXAxisValue, selectorChartXAxis, selectorChartControlledCartesianAxisHighlight, selectorChartsKeyboardXAxisIndex, selectorChartsLastInteraction, selectorBrushShouldPreventAxisHighlight, selectAxisHighlightWithValue);
export const selectorChartsHighlightYAxisValue = createSelectorMemoized(selectorChartsInteractionYAxisIndex, selectorChartsInteractionYAxisValue, selectorChartYAxis, selectorChartControlledCartesianAxisHighlight, selectorChartsKeyboardYAxisIndex, selectorChartsLastInteraction, selectorBrushShouldPreventAxisHighlight, selectAxisHighlightWithValue);

/**
 * Get the scale of the axis with highlight if controlled. The default axis otherwise.
 * @param controlledItem The controlled value of highlightedAxis
 * @param axis The axis state after all the processing
 * @returns axis state
 */
const selectAxis = (axisItems, axis) => {
  if (axisItems === undefined) {
    return [axis.axis[axis.axisIds[0]]];
  }
  const filteredAxes = axisItems.map(item => axis.axis[item.axisId] ?? null).filter(item => item !== null);
  return filteredAxes;
};
export const selectorChartsHighlightXAxis = createSelector(selectorChartControlledCartesianAxisHighlight, selectorChartXAxis, selectAxis);
export const selectorChartsHighlightYAxis = createSelector(selectorChartControlledCartesianAxisHighlight, selectorChartYAxis, selectAxis);